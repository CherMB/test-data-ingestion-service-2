{
    "widget": {
        "id": "e7",
        "title": "Code Progression Snapshot",
        "description": "It highlights the journey of code from pull requests, through builds, to deployments, providing view into the overall efficiency. You have to specify the step type in the workflow for us to compute this.",
        "content": [
            {
                "header": [
                    {
                        "title": "Run-initiating commits",
                        "description": "",
                        "enable_components_compare": true,
                        "components_compare_id": "run-initiating-commits-compare",
                        "post_process_function_name": "Merged Default Branch Commits Header",
                        "drill_down": {
                            "report_id": "runInitiatingCommits",
                            "report_title": "Run-Initiating commits"
                        }
                    }
                ],
                "section": [
                    {
                        "type": 4,
                        "show_legends": false,
                        "color_scheme": [
                            {
                                "color0": "#9FB6C1",
                                "color1": "#577688"
                            },
                            {
                                "color0": "#9FB6C1",
                                "color1": "#577688"
                            },
                            {
                                "color0": "#9FB6C1",
                                "color1": "#577688"
                            },
                            {
                                "color0": "#62B0FF",
                                "color1": "#1D69FF"
                            }
                        ],
                        "light_color_scheme": [
                            {
                                "color0": "#AFBFC6",
                                "color1": "#7490A1"
                            }
                        ],
                        "post_process_function_name": "Merged Default Branch Commits Section",
                        "drill_down": {
                            "report_id": "runInitiatingCommits",
                            "report_title": "Run-Initiating commits",
                            "report_type": "environment"
                        }
                    }
                ]
            },
            {
                "header": [
                    {
                        "title": "Builds",
                        "description": "",
                        "enable_components_compare": true,
                        "components_compare_id": "builds-compare",
                        "post_process_function_name": "Total Builds Header",
                        "drill_down": {
                            "report_id": "builds",
                            "report_title": "Builds"
                        }
                    }
                ],
                "section": [
                    {
                        "type": 6,
                        "show_legends": true,
                        "data_type": 1,
                        "color_scheme": [
                            {
                                "color0": "#09DE83",
                                "color1": "#06A964"
                            },
                            {
                                "color0": "#FEA3A5",
                                "color1": "#E02227"
                            }
                        ],
                        "light_color_scheme": [
                            {
                                "color0": "#79CAA8",
                                "color1": "#0C9E61"
                            },
                            {
                                "color0": "#E83D39",
                                "color1": "#F39492"
                            }
                        ],
                        "post_process_function_name": "Total Builds Section",
                        "drill_down": {
                            "report_id": "builds",
                            "report_title": "Builds",
                            "report_type": "status"
                        }
                    }
                ]
            },
            {
                "header": [
                    {
                        "title": "Successful deployments",
                        "description": "",
                        "enable_components_compare": true,
                        "components_compare_id": "successful-deployments-compare",
                        "post_process_function_name": "Deployments Header",
                        "drill_down": {
                            "report_id": "deployments",
                            "report_title": "Deployments"
                        }
                    }
                ],
                "section": [
                    {
                        "type": 4,
                        "show_legends": false,
                        "color_scheme": [
                            {
                                "color0": "#9FB6C1",
                                "color1": "#577688"
                            },
                            {
                                "color0": "#9FB6C1",
                                "color1": "#577688"
                            },
                            {
                                "color0": "#9FB6C1",
                                "color1": "#577688"
                            }
                        ],
                        "light_color_scheme": [
                            {
                                "color0": "#AFBFC6",
                                "color1": "#7490A1"
                            }
                        ],
                        "post_process_function_name": "Deployments Section",
                        "drill_down": {
                            "report_id": "deployments",
                            "report_title": "Deployments",
                            "report_type": "environment"
                        }
                    }
                ]
            }
        ]
    },
    "queries": {
        "totalBuildsHeader": {
            "alias": "build_data",
            "query": {
                "size": 0,
                "query": {
                    "bool": {
                        "filter": [
                            {
                                "range": {
                                    "status_timestamp": {
                                        "gte": "{{.startDate}}",
                                        "lte": "{{.endDate}}",
                                        "format": "yyyy-MM-dd HH:mm:ss",
                                        "time_zone": "{{.timeZone}}"
                                    }
                                }
                            },
                            {
                                "term": {
                                    "org_id": "{{.orgId}}"
                                }
                            },
                            {
                                "term": {
                                    "step_kind": "build"
                                }
                            },
                            {
                                "term": {
                                    "data_type": 2
                                }
                            },
                            {
                                "bool": {
                                    "should": [
                                        {
                                            "term": {
                                                "status": "SUCCEEDED"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "FAILED"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "TIMED_OUT"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "ABORTED"
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                },
                "aggs": {
                    "total_builds": {
                        "scripted_metric": {
                            "init_script": "state.data_map=[:];",
                            "map_script": "def map=state.data_map;def key=doc.component_id.value+'_'+doc.run_id.value+'_'+doc.job_id.value+'_'+doc.step_id.value+'_'+doc.status.value+'_'+doc._id.value;def v=['component_id':doc.component_id.value,'run_id':doc.run_id.value,'job_id':doc.job_id.value,'step_id':doc.step_id.value,'status':doc.status.value];map.put(key,v);",
                            "combine_script": "return state.data_map;",
                            "reduce_script": "def tmpMap=new HashMap(),allDataMap=new HashMap();for(response in states){if(response!=null){for(key in response.keySet()){def record=response.get(key);allDataMap.put(key,record);}}}def jobLevelKeys=new HashSet();for(record in allDataMap.values()){if(record.step_id==''){def dedupKey=record.component_id+'_'+record.run_id+'_'+record.job_id;jobLevelKeys.add(dedupKey);}}def dedupKeys=new HashSet();for(entry in allDataMap.entrySet()){def record=entry.getValue();def dedupKey=record.component_id+'_'+record.run_id+'_'+record.job_id;def fullKey=entry.getKey();if(jobLevelKeys.contains(dedupKey)){if(record.step_id==''){tmpMap.put(fullKey,record);}}else{tmpMap.put(fullKey,record);}}return tmpMap.size();"
                        }
                    }
                }
            }
        },
        "buildsData": {
            "alias": "build_data",
            "query": {
                "_source": false,
                "size": 0,
                "query": {
                    "bool": {
                        "filter": [
                            {
                                "range": {
                                    "status_timestamp": {
                                        "gte": "{{.startDate}}",
                                        "lte": "{{.endDate}}",
                                        "format": "yyyy-MM-dd HH:mm:ss",
                                        "time_zone": "{{.timeZone}}"
                                    }
                                }
                            },
                            {
                                "term": {
                                    "org_id": "{{.orgId}}"
                                }
                            },
                            {
                                "term": {
                                    "step_kind": "build"
                                }
                            },
                            {
                                "term": {
                                    "data_type": 2
                                }
                            },
                            {
                                "bool": {
                                    "should": [
                                        {
                                            "term": {
                                                "status": "SUCCEEDED"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "FAILED"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "TIMED_OUT"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "ABORTED"
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                },
                "aggs": {
                    "build_status": {
                        "scripted_metric": {
                            "init_script": "state.data_map=[:];",
                            "map_script": "def map=state.data_map;def key=doc.component_id.value+'_'+doc.run_id.value+'_'+doc.job_id.value+'_'+doc.step_id.value+'_'+doc.status.value+'_'+doc._id.value;def v=['component_id':doc.component_id.value,'run_id':doc.run_id.value,'job_id':doc.job_id.value,'step_id':doc.step_id.value,'status':doc.status.value];map.put(key,v);",
                            "combine_script": "return state.data_map;",
                            "reduce_script": "def tmpMap=[:],allDataMap=[:],resultMap=new HashMap(),countMap=new HashMap(),totalCount=0.0;for(response in states){if(response!=null){for(key in response.keySet()){def record=response.get(key);allDataMap.put(key,record);}}}def jobLevelKeys=new HashSet();for(record in allDataMap.values()){if(record.step_id==''){def dedupKey=record.component_id+'_'+record.run_id+'_'+record.job_id;jobLevelKeys.add(dedupKey);}}def dedupKeys=new HashSet();for(entry in allDataMap.entrySet()){def record=entry.getValue();def dedupKey=record.component_id+'_'+record.run_id+'_'+record.job_id;def fullKey=entry.getKey();if(jobLevelKeys.contains(dedupKey)){if(record.step_id==''){tmpMap.put(fullKey,record);}}else{tmpMap.put(fullKey,record);}}for(key in tmpMap.keySet()){def mapRecord=tmpMap.get(key);def status=mapRecord.status;if(status=='SUCCEEDED'){status='Success';}else if(['FAILED','TIMED_OUT','ABORTED'].contains(status)){status='Failure';}if(countMap.containsKey(status)){countMap.put(status,countMap.get(status)+1);}else{countMap.put(status,1);}totalCount++;}def dataArray=[],infoArray=[],statusArray=['Success','Failure'];def drilldownMap=['reportId':'builds','reportType':'status','reportTitle':'Builds'];for(key in statusArray){def count=countMap.containsKey(key)?countMap.get(key):0;def percent=totalCount>0?Math.round((count/totalCount)*100):0;dataArray.add(['name':key,'value':percent]);infoArray.add(['title':key,'value':count,'drillDown':drilldownMap]);}resultMap.put('data',dataArray);resultMap.put('info',infoArray);return resultMap;"
                        }
                    }
                }
            }
        },
        "deploymentsHeader": {
            "alias": "deploy_data",
            "query": {
                "_source": false,
                "size": 0,
                "query": {
                    "bool": {
                        "filter": [
                            {
                                "range": {
                                    "status_timestamp": {
                                        "gte": "{{.startDate}}",
                                        "lte": "{{.endDate}}",
                                        "format": "yyyy-MM-dd HH:mm:ss",
                                        "time_zone": "{{.timeZone}}"
                                    }
                                }
                            },
                            {
                                "term": {
                                    "org_id": "{{.orgId}}"
                                }
                            },
                            {
                                "term": {
                                    "data_type": 2
                                }
                            },
                            {
                                "bool": {
                                    "should": [
                                        {
                                            "term": {
                                                "status": "SUCCEEDED"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "bool": {
                                    "must_not": [
                                        {
                                            "term": {
                                                "target_env": ""
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                },
                "aggs": {
                    "deploy_count": {
                        "scripted_metric": {
                            "init_script": "state.data_map=[:];",
                            "map_script": "def map = state.data_map;def key =doc.run_id.value + '_' + doc.job_id.value + '_' + doc.step_id.value + '_' + doc.target_env.value + '_' + doc.status.value;def v = ['automation_id':doc.automation_id.value, 'component_id':doc.component_id.value, 'org_id':doc.org_id.value, 'component_name':doc.component_name.value, 'target_env':doc.target_env.value, 'step_kind':doc.step_kind.value, 'run_number':doc.run_number.value, 'workflow_name':doc.workflow_name.value, 'run_id':doc.run_id.value, 'status':doc.status.value, 'duration':doc.duration.value, 'status_timestamp':doc.status_timestamp.value, 'workflow_name':doc.workflow_name.value, 'org_name':doc.org_name.value];map.put(key, v);",
                            "combine_script": "return state.data_map;",
                            "reduce_script": "def resultMap = new HashMap(), jobStepDedupMap = new HashMap();for (response in states){if (response != null){for (key in response.keySet()){resultMap.put(key, response.get(key));}}}for (key in resultMap.keySet()){def currRecord = resultMap.get(key);if (currRecord.step_id == ''){jobStepDedupMap.put(key, currRecord);} else{def jobLevelRecordKey = currRecord.run_id + '_' + currRecord.job_id + '_' + '' + '_' + currRecord.target_env + '_' + currRecord.status;if (!resultMap.containsKey(jobLevelRecordKey)){jobStepDedupMap.put(key, currRecord);}}}return jobStepDedupMap.size();"
                        }
                    }
                }
            }
        },
        "envDeploymentInfo": {
            "alias": "deploy_data",
            "query": {
                "_source": false,
                "size": 0,
                "query": {
                    "bool": {
                        "filter": [
                            {
                                "range": {
                                    "status_timestamp": {
                                        "gte": "{{.startDate}}",
                                        "lte": "{{.endDate}}",
                                        "format": "yyyy-MM-dd HH:mm:ss",
                                        "time_zone": "{{.timeZone}}"
                                    }
                                }
                            },
                            {
                                "term": {
                                    "org_id": "{{.orgId}}"
                                }
                            },
                            {
                                "term": {
                                    "data_type": 2
                                }
                            },
                            {
                                "bool": {
                                    "should": [
                                        {
                                            "term": {
                                                "status": "SUCCEEDED"
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "bool": {
                                    "must_not": [
                                        {
                                            "term": {
                                                "target_env": ""
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                },
                "aggs": {
                    "deploys": {
                        "scripted_metric": {
                            "init_script": "state.data_map=[:];",
                            "map_script": "def map = state.data_map;def key =doc.run_id.value + '_' + doc.job_id.value + '_' + doc.step_id.value + '_' + doc.target_env.value + '_' + doc.status.value;def v = ['target_env':doc.target_env.value, 'run_id':doc.run_id.value, 'job_id':doc.job_id.value, 'step_id':doc.step_id.value, 'status':doc.status.value, 'timestamp':doc.timestamp.value];map.put(key, v);",
                            "combine_script": "return state.data_map;",
                            "reduce_script": "def tmpMap = [:], out = [:], resultMap = new HashMap(), countMap = new HashMap(), totalCount = 0.0, jobStepDedupMap = new HashMap();for (response in states){if (response != null){for (key in response.keySet()){tmpMap.put(key, response.get(key));}}}for (key in tmpMap.keySet()){def currRecord = tmpMap.get(key);if (currRecord.step_id == ''){jobStepDedupMap.put(key, currRecord);} else{def jobLevelRecordKey = currRecord.run_id + '_' + currRecord.job_id + '_' + '' + '_' + currRecord.target_env + '_' + currRecord.status;if (!tmpMap.containsKey(jobLevelRecordKey)){jobStepDedupMap.put(key, currRecord);}}}for (key in jobStepDedupMap.keySet()){def mapRecord = jobStepDedupMap.get(key);def targetEnv = mapRecord.target_env;if (countMap.containsKey(targetEnv)){def count = countMap.get(targetEnv);countMap.put(targetEnv, count + 1);totalCount++;} else{countMap.put(targetEnv, 1);totalCount++;}}def dataArray = [], infoArray = [];for (key in countMap.keySet()){def data = ['x':key, 'y':countMap.get(key)];dataArray.add(data)}resultMap.put('data', dataArray);return resultMap;"
                        }
                    }
                }
            }
        },
        "automationRunsCount": {
            "alias": "automation_run_status",
            "query": {
                "_source": false,
                "size": 0,
                "query": {
                    "bool": {
                        "filter": [
                            {
                                "range": {
                                    "status_timestamp": {
                                        "gte": "{{.startDate}}",
                                        "lte": "{{.endDate}}",
                                        "format": "yyyy-MM-dd HH:mm:ss",
                                        "time_zone": "{{.timeZone}}"
                                    }
                                }
                            },
                            {
                                "term": {
                                    "org_id": "{{.orgId}}"
                                }
                            },
                            {
                                "term": {
                                    "job_id": ""
                                }
                            },
                            {
                                "term": {
                                    "step_id": ""
                                }
                            },
                            {
                                "term": {
                                    "data_type": 2
                                }
                            },
                            {
                                "bool": {
                                    "must_not": [
                                        {
                                            "term": {
                                                "commit_sha": ""
                                            }
                                        }
                                    ]
                                }
                            },
                            {
                                "bool": {
                                    "should": [
                                        {
                                            "term": {
                                                "status": "SUCCEEDED"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "FAILED"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "TIMED_OUT"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "ABORTED"
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                },
                "aggs": {
                    "automation_run": {
                        "scripted_metric": {
                            "init_script": "state.data_map=[:];",
                            "map_script": "def map = state.data_map;def key = doc.org_id+'_'+doc.automation_id.value + '_' + doc.run_id.value+'_'+doc.status.value;def v = ['run_id': doc.run_id.value, 'status': doc.status.value,'automation_id':doc.automation_id.value];map.put(key, v);",
                            "combine_script": "return state.data_map;",
                            "reduce_script": "def resultMap = new HashMap();def tmpMap = new HashMap();def dataMap = new HashMap();for (response in states) {if (response != null) {for (key in response.keySet()) {tmpMap.put(key, response.get(key));}}}for (key in tmpMap.keySet()) {def record = tmpMap.get(key);def runKey = record.automation_id+'_'+record.run_id;if (dataMap.containsKey(runKey)) {def count = dataMap.get(runKey);dataMap.put(runKey, count + 1);} else {dataMap.put(runKey, 1);}}resultMap.put('data', dataMap);resultMap.put('totalCount', dataMap.size());return resultMap;"
                        }
                    }
                }
            }
        },
        "deployedAutomationCount": {
            "alias": "deploy_data",
            "query": {
                "_source": false,
                "size": 0,
                "query": {
                    "bool": {
                        "filter": [
                            {
                                "range": {
                                    "status_timestamp": {
                                        "gte": "{{.startDate}}",
                                        "lte": "{{.endDate}}",
                                        "format": "yyyy-MM-dd HH:mm:ss",
                                        "time_zone": "{{.timeZone}}"
                                    }
                                }
                            },
                            {
                                "term": {
                                    "org_id": "{{.orgId}}"
                                }
                            },
                            {
                                "term": {
                                    "status": "SUCCEEDED"
                                }
                            },
                            {
                                "term": {
                                    "data_type": 2
                                }
                            },
                            {
                                "bool": {
                                    "must_not": [
                                        {
                                            "term": {
                                                "target_env": ""
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                },
                "aggs": {
                    "automation_run": {
                        "scripted_metric": {
                            "init_script": "state.data_map=[:];",
                            "map_script": "def map = state.data_map;def key = doc.automation_id.value + '_' + doc.run_id.value + '_' + doc.job_id.value + '_' + doc.step_id.value + '_' + doc.status.value + '_' + doc.status_timestamp.value;def v = ['automation_id': doc.automation_id.value, 'run_id': doc.run_id.value, 'job_id': doc.job_id.value, 'step_id': doc.step_id.value, 'target_env': doc.target_env.value, 'status': doc.status.value];map.put(key, v);",
                            "combine_script": "return state.data_map;",
                            "reduce_script": "def resultMap = new HashMap();def tmpMap = new HashMap();def dataMap = new HashMap();for (response in states) {if (response != null) {for (key in response.keySet()) {tmpMap.put(key, response.get(key));}}}for (key in tmpMap.keySet()) {def record = tmpMap.get(key);def automationKey = record.automation_id + '_'+record.run_id;def envKey = record.target_env;if (dataMap.containsKey(automationKey)) {def envMap = dataMap.get(automationKey);if (envMap.containsKey(envKey)) {envMap.put(envKey, envMap.get(envKey) + 1);} else {envMap.put(envKey, 1);}} else {def envMap = new HashMap();envMap.put(envKey, 1);dataMap.put(automationKey, envMap);}}resultMap.put('data', dataMap);return resultMap;"
                        }
                    }
                }
            }
        }
    },
    "specs": {
        "totalBuildsHeaderSpec": [
            {
                "operation": "shift",
                "spec": {
                    "aggregations": {
                        "total_builds": {
                            "value": "value"
                        }
                    }
                }
            }
        ],
        "buildsDataSpec": [
            {
                "operation": "shift",
                "spec": {
                    "aggregations": {
                        "build_status": {
                            "value": {
                                "*": "&"
                            }
                        }
                    }
                }
            }
        ],
        "deploymentsHeaderSpec": [
            {
                "operation": "shift",
                "spec": {
                    "aggregations": {
                        "deploy_count": {
                            "value": "value"
                        }
                    }
                }
            }
        ],
        "envDeploymentInfoSpec": [
            {
                "operation": "shift",
                "spec": {
                    "aggregations": {
                        "deploys": {
                            "value": {
                                "*": "&"
                            }
                        }
                    }
                }
            },
            {
                "operation": "default",
                "spec": {
                    "data": [],
                    "id": "Successful deployments"
                }
            },
            {
                "operation": "shift",
                "spec": {
                    "@": "[]"
                }
            }
        ]
    }
}