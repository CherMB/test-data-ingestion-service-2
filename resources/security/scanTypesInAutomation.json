{
  "widget": {
    "id": "s6",
    "title": "Scan types in automations",
    "description": "",
    "content": [
      {
        "section": [
          {
            "type": 4,
            "show_legends": true,
            "color_scheme": [
              {
                "color0": "#9FB6C1",
                "color1": "#577688"
              },
              {
                "color0": "#62B0FF",
                "color1": "#1D69FF"
              }
            ],
            "light_color_scheme": [
              {
                "color0": "#B1CDE0",
                "color1": "#769BB2"
              },
              {
                "color0": "#35B1F9",
                "color1": "#0782D2"
              }
            ],
            "post_process_function_name": "scan types in automation",
            "spec_key": "scanTypesInAutomationsSpec",
            "drill_down": {
              "report_id": "security-scan-type-workflows",
              "report_title": "Scan types in workflows",
              "report_type": "scanType"
            }
          }
        ]
      }
    ]
  },
  "queries": {
    "scanAutomationResp": {
      "alias": "scan_results",
      "query": {
        "size": 0,
        "_source": false,
        "query": {
          "bool": {
            "filter": [
              {
                "range": {
                  "scan_time": {
                    "gte": "{{.startDate}}",
                    "lte": "{{.endDate}}",
                    "format": "yyyy-MM-dd HH:mm:ss",
                    "time_zone":"{{.timeZone}}"
                  }
                }
              },
              {
                "term": {
                  "org_id": "{{.orgId}}"
                }
              },
              {
                "terms": {
                  "severity": [
                    "MEDIUM",
                    "HIGH",
                    "LOW",
                    "VERY_HIGH",
                    "CRITICAL"
                  ]
                }
              }
            ]
          }
        },
        "aggs": {
          "scanTypesInAutomation": {
            "scripted_metric": {
              "init_script": "state.statusMap = [:];",
              "map_script": "def map=state.statusMap;def key=doc.automation_id.value+'_'+'_'+doc.scanner_type.value+'_'+doc.run_id.value;def v=['scanner_type':(doc.scanner_type.value),'run_id':doc.run_id.value,'automation_id':doc.automation_id.value];map.put(key,v);",
              "combine_script": "return state.statusMap;",
              "reduce_script": "int count=0;def result=[:];def countMap=null;def scannerTypeCountMap=new HashMap();def resultMap=new HashMap();def resultRunList=new ArrayList();def resultAutomationList=new ArrayList();def runSet=null;def automationSet=null;for(a in states){if(a!=null){for(i in a.keySet()){def record=a.get(i);if(scannerTypeCountMap.containsKey(record.scanner_type)){countMap=scannerTypeCountMap.get(record.scanner_type);runSet=countMap.get('runs');automationSet=countMap.get('automations');runSet.add(record.run_id);automationSet.add(record.automation_id);countMap.put('runs',runSet);countMap.put('automations',automationSet);scannerTypeCountMap.put(record.scanner_type,countMap);}else{runSet=new HashSet();automationSet=new HashSet();runSet.add(record.run_id);automationSet.add(record.automation_id);countMap=new HashMap();countMap.put('runs',runSet);countMap.put('automations',automationSet);scannerTypeCountMap.put(record.scanner_type,countMap);}}}}for(type in scannerTypeCountMap.keySet()){def finalMap=scannerTypeCountMap.get(type);def automationRecord=['x':type,'y':finalMap.get('automations').size()];def runRecord=['x':type,'y':finalMap.get('runs').size()];resultRunList.add(runRecord);resultAutomationList.add(automationRecord);}resultMap.put('automationKey','Workflows');resultMap.put('automationResult',resultAutomationList);resultMap.put('runKey','Workflow Runs');resultMap.put('runResult',resultRunList);return resultMap;"
            }
          }
        }
      }
    },
    "automationRunResp": {
      "alias": "automation_run_status",
      "query": {
        "_source": false,
        "size": 0,
        "query": {
          "bool": {
            "filter": [
            {
              "term": {
              "org_id": "{{.orgId}}"
              }
            },
            {
              "range": {
              "status_timestamp": {
                "gte": "{{.startDate}}",
                "lte": "{{.endDate}}",
                "format": "yyyy-MM-dd HH:mm:ss||strict_date_optional_time ||epoch_millis",
                "time_zone":"{{.timeZone}}"
              }
              }
            },
            {
              "term": {
              "job_id": ""
              }
            },
            {
              "term": {
              "step_id": ""
              }
            },
            {
              "bool": {
              "should": [
                {
                "term": {
                  "status": "SUCCEEDED"
                }
                },
                {
                "term": {
                  "status": "FAILED"
                }
                },
                {
                  "term": {
                    "status": "TIMED_OUT"
                  }
                },
                {
                  "term": {
                    "status": "ABORTED"
                  }
                }
              ]
              }
            }
            ]
          }
        },
        "aggs": {
          "automation_run_activity": {
            "scripted_metric": {
            "init_script": "state.data_map=[:];",
            "map_script": "def map = state.data_map;def key = doc.org_id+'_'+doc.automation_id.value + '_' + doc.run_id.value + '_' + doc.status.value;def v = ['status_timestamp': doc.status_timestamp.value, 'component_id': doc.component_id.value,'component_name': doc.component_name.value, 'automation_id': doc.automation_id.value, 'run_id': doc.run_id.value, 'status': doc.status.value, 'duration': doc.duration.value, 'run_number':doc['workflow_info.run_number'].value];map.put(key, v);",
            "combine_script": "return state.data_map;",
            "reduce_script": "def tmpMap = [: ], resultMap = new HashMap();for (response in states) {if (response != null) {for (key in response.keySet()) {def record = response.get(key);if (tmpMap.containsKey(key)) {def mapRecord = tmpMap.get(key);if (mapRecord.status_timestamp.getMillis() > record.status_timestamp.getMillis()) {if (mapRecord.status == 'SUCCEEDED') {mapRecord.status = 'Success';} else if(mapRecord.status == 'FAILED' || mapRecord.status == 'TIMED_OUT' || mapRecord.status == 'ABORTED') {mapRecord.status = 'Failure';}tmpMap.put(key, mapRecord);}} else {if (record.status == 'SUCCEEDED') {record.status = 'Success';} else if(record.status == 'FAILED' || record.status == 'TIMED_OUT' || record.status == 'ABORTED') {record.status = 'Failure';}tmpMap.put(key, record);}}}}for (key in tmpMap.keySet()) {def mapRecord = tmpMap.get(key);def run_id = mapRecord.run_id;def automation_id = mapRecord.automation_id;def status = mapRecord.status;if (resultMap.containsKey(automation_id)) {def runList = resultMap.get(automation_id);runList.add(mapRecord);} else {def runList = new ArrayList();runList.add(mapRecord);resultMap.put(automation_id, runList);}}return resultMap;"
            }
          }
        }
      }
    },
    "scannerTypeResp": {
      "alias": "scan_results",
      "query": {
        "_source": false,
        
        "size": 0,
        
        "query": {
          "bool": {
          "filter": [
            {
            "term": {
              "org_id": "{{.orgId}}"
            }
            },
        
            {
            "range": {
              "scan_time": {
              "gte": "{{.startDate}}",
        
              "lte": "{{.endDate}}",
        
              "format": "yyyy-MM-dd HH:mm:ss||strict_date_optional_time ||epoch_millis"
              }
            }
            }
          ]
          }
        },
        "aggs": {
          "distinct_run": {
          "scripted_metric": {
            "init_script": "state.data_map=[:];",
            "map_script": "def map = state.data_map;def key = doc.org_id.value + '_' + doc.component_id.value + '_' + doc.automation_id.value + '_' + doc.scanner_name.value + '_' + doc.scanner_type.value + '_' + doc.run_id.value; def v = ['automation_id': doc.automation_id.value, 'scanner_name': doc.scanner_name.value, 'scanner_type': doc.scanner_type.value,'run_id': doc.run_id.value];map.put(key, v);",
            "combine_script": "return state.data_map;",
            "reduce_script": "def tmpMap = [:];def resultMap = new HashMap();for (response in states){if (response != null){for (key in response.keySet()){def record = response.get(key);def runIDKey = record.run_id;def scannerName = record.scanner_name;def scannerType = record.scanner_type;if (tmpMap.containsKey(runIDKey)){def extraMap = tmpMap.get(runIDKey);extraMap.get('scanner_names').add(scannerName);extraMap.get('scanner_types').add(scannerType);tmpMap.put(runIDKey, extraMap);} else{def scannerNamesList = new HashSet();def scannerTypes = new HashSet();def extraMap = new HashMap();scannerNamesList.add(scannerName);scannerTypes.add(scannerType);extraMap.put('scanner_names', scannerNamesList);extraMap.put('scanner_types', scannerTypes);tmpMap.put(runIDKey, extraMap);}}}}return tmpMap;"
            }
          }
        }
        }
    }
  }
}