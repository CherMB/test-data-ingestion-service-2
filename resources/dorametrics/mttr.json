{
    "widget": {
        "id": "d4",
        "title": "Mean time to recovery",
        "description": "For the selected time frame, track the time it takes to recover from a service failure, measured as the average time between a bug report and deployment of the bug fix.",
        "enable_components_compare": true,
        "components_compare_id": "mttr-compare",
        "content": [
            {
                "header": [
                    {
                        "title": "Average duration",
                        "description": "Average mean time to recovery duration per hour",
                        "post_process_function_name": "mean time to recovery",
                        "spec_key": "mttrHeaderSpec",
                        "drill_down": {
                            "report_id": "doraMetrics-mttr",
                            "report_title": "Time to recovery",
                            "report_info": {
                                "deployment_env": "{{.targetEnv}}"
                            }
                        }
                    }
                ]
            }
        ]
    },
    "queries": {
        "mttrHeader": {
            "alias": "deploy_data",
            "query": {
                "size": 0,
                "query": {
                    "bool": {
                        "filter": [
                            {
                                "range": {
                                    "status_timestamp": {
                                        "gte": "{{.startDate}}",
                                        "lte": "{{.endDate}}",
                                        "format": "yyyy-MM-dd HH:mm:ss",
                                        "time_zone": "{{.timeZone}}"
                                    }
                                }
                            },
                            {
                                "term": {
                                    "org_id": "{{.orgId}}"
                                }
                            },
                            {
                                "term": {
                                    "data_type": 2
                                }
                            },
                            {
                                "term": {
                                    "target_env": "{{.targetEnv}}"
                                }
                            }
                        ]
                    }
                },
                "aggs": {
                    "deployments": {
                        "scripted_metric": {
                            "combine_script": "return state.data_map;",
                            "init_script": "state.data_map=[:];",
                            "map_script": "def map = state.data_map, runStartTime = 0; def key = doc.component_id.value + '_' + doc.run_id.value + '_' + doc.run_number.value + '_' + doc.job_id.value + '_' + doc.step_id.value + '_' + doc.target_env.value + '_' + doc.status.value; def v = ['run_id':doc.run_id.value, 'run_number':doc.run_number.value, 'job_id':doc.job_id.value, 'step_id':doc.step_id.value, 'target_env':doc.target_env.value, 'step_kind':doc.step_kind.value, 'status_timestamp':doc.status_timestamp.value, 'status':doc.status.value, 'component_id':doc.component_id.value, 'automation_id':doc.automation_id.value, 'workflow_name':doc.workflow_name.value, 'component_name':doc.component_name.value]; if (doc['run_start_time'].size() != 0){ runStartTime = doc.run_start_time.value;} v['run_start_time'] = runStartTime; map.put(key, v);",
                            "reduce_script": "def allDataMap = new HashMap(), componentMap = new HashMap(), jobStepDedupMap = new HashMap(); for (response in states){ if (response != null){ for (key in response.keySet()){ allDataMap.put(key, response.get(key));}}}for (key in allDataMap.keySet()){def currRecord = allDataMap.get(key);if (currRecord.step_id == ''){jobStepDedupMap.put(key, currRecord);} else{def jobLevelRecordKey = currRecord.component_id + '_' + currRecord.run_id + '_' + currRecord.job_id + '_' + '' + '_' + currRecord.target_env + '_' + currRecord.status;if (!allDataMap.containsKey(jobLevelRecordKey)){jobStepDedupMap.put(key, currRecord);}}} for (key in jobStepDedupMap.keySet()){ def record = jobStepDedupMap.get(key); def compArray = new ArrayList(); if (componentMap.containsKey(record.component_id)){ compArray = componentMap.get(record.component_id);} compArray.add(record); componentMap.put(record.component_id, compArray);} def recoveredCount = 0.0, recoveredTotalDuration = 0.0; for (key in componentMap.keySet()){ def componentArray = componentMap.get(key); for (def i = 0; i < componentArray.size(); i++){ for (def j = i + 1; j < componentArray.size(); j++){ if (componentArray[i].status_timestamp.getMillis() > componentArray[j].status_timestamp.getMillis()){ def temp = componentArray[i]; componentArray[i] = componentArray[j]; componentArray[j] = temp;}}} def failedTime = 0, failedRunNumber = 0; for (def i = 0; i < componentArray.size(); i++){ def status = componentArray[i].status; def runNumber = componentArray[i].run_number; if ((status == 'FAILED' || status == 'TIMED_OUT' || status == 'ABORTED') && failedTime == 0){ failedTime = componentArray[i].status_timestamp.getMillis(); failedRunNumber = runNumber;} if (failedTime != 0 && status == 'SUCCEEDED' && failedRunNumber < runNumber){ def successTime = componentArray[i].status_timestamp.getMillis(); recoveredTotalDuration += (successTime - failedTime); recoveredCount += 1; failedTime = 0; failedRunNumber = 0;}}} def result = 0.0; if (recoveredCount != 0 || recoveredTotalDuration != 0){ result = recoveredTotalDuration / recoveredCount;} return result;"
                        }
                    }
                }
            }
        }
    }
}