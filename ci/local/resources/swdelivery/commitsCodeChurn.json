{
  "widget": {
    "id": "e6",
    "title": "Code Churn",
    "descripition": "Track code addition and deletion over time.",
    "content": [
      {
        "section": [
          {
            "type": 1,
            "show_legends": true,
            "color_scheme": [
              {
                "color0": "#0A7146",
                "color1": "#00CC75"
              },
              {
                "color0": "#BC191D",
                "color1": "#FB6E72"
              },
              {
                "color0": "#ECAA06",
                "color1": "#FFDB4C"
              }
            ],
            "light_color_scheme": [
              {
                "color0": "#7ACAA9",
                "color1": "#0B9D60"
              },
              {
                "color0": "#E83C38",
                "color1": "#F29492"
              },
              {
                "color0": "#F4C227",
                "color1": "#FCE464"
              }
            ],
            "post_process_function_name":"code churn",
            "spec_key": "codeChurnChartSpec"
          }
        ]
      }
    ]
  },
  "queries": {
    "codeChurnChart": {
      "alias": "cb_commits_code_churn_data",
      "query": {
        "_source": false,
        "size": 0,
        "query": {
          "bool": {
            "filter": [
              {
                "range": {
                  "timestamp": {
                    "gte": "{{.startDate}}",
                    "lte": "{{.endDate}}",
                    "format": "yyyy-MM-dd HH:mm:ss",
                    "time_zone":"{{.timeZone}}"
                  }
                }
              },
              {
                "term": {
                  "org_id": "{{.orgId}}"
                }
              }
            ]
          }
        },
        "aggs": {
          "code_churn_buckets": {
            "date_histogram": {
              "field": "timestamp",
              "calendar_interval": "{{.aggrBy}}",
              "min_doc_count": 0,
              "format": "yyyy-MM-dd",
              "time_zone":"{{.timeZone}}",
              "extended_bounds": {
                "min": "{{.dateHistogramMin}}",
                "max": "{{.dateHistogramMax}}"
              }
            },
            "aggs": {
              "code_churn": {
                "scripted_metric": {
                  "init_script": "state.data_map=[:];",
                  "map_script": "def map = state.data_map;def key = doc.org_id.value + '_' + doc.provider.value + '_' + doc.commit_sha.value + '_' + doc.component_id.value + '_' + doc.repository_name.value + '_' + (doc.timestamp.getValue().toEpochSecond() * 1000);def v = ['org_id': doc.org_id.value, 'provider': doc.provider.value, 'commit_sha': doc.commit_sha.value, 'component_id': doc.component_id.value, 'repository_name': doc.repository_name.value, 'lines_added': doc.lines_added.value, 'lines_deleted': doc.lines_deleted.value, 'timestamp': (doc.timestamp.getValue().toEpochSecond() * 1000)];map.put(key, v);",
                  "combine_script": "return state.data_map;",
                  "reduce_script": "def tmpMap = [: ];def out = [: ];def countMap = new HashMap();for (agg in states) {    if (agg != null) {        for (key in agg.keySet()) {            def record = agg.get(key);            def devkey = record.org_id + '_' + record.provider + '_' + record.commit_sha + '_' + record.component_id + '_' + record.repository_name;            if (tmpMap.containsKey(devkey)) {                def mapRecord = tmpMap.get(devkey);                if (mapRecord.timestamp < record.timestamp) {                    tmpMap.put(devkey, record);                }            } else {                tmpMap.put(devkey, record);            }        }    }}def timeArray = ['lines_added', 'lines_deleted'];for (key in tmpMap.keySet()) {    def v = tmpMap.get(key);    for (timeKey in timeArray) {        if (countMap.containsKey(timeKey)) {            def count = countMap.get(timeKey);            count = count + v[timeKey];            countMap.put(timeKey, count);        } else {            countMap.put(timeKey, v[timeKey]);        }    }}return countMap;"
                }
              }
            }
          }
        }
      }
    }
  }
}