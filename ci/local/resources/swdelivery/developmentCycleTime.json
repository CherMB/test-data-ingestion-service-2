{
  "widget": {
    "id": "e10",
    "title": "Development Cycle",
    "descripition": "Track successful deployments over the selected duration. Averages are displayed for time to pick up a task, coding time and time to code review.",
    "enable_components_compare": true,
    "components_compare_id": "development-cycle-compare",
    "content": [
      {
        "header": [
          {
            "title": "Average Development Cycle Time",
            "descripition": "",
            "post_process_function_name": "Average Development Cycle Time Header"
          }
        ],
        "section": [
          {
            "type": 2,
            "show_legends": true,
            "color_scheme": [
              {
                "color0": "#7D83FF",
                "color1": "#333BFA"
              },
              {
                "color0": "#FD578F",
                "color1": "#D02D64"
              },
              {
                "color0": "#BA68C8",
                "color1": "#A13DB3"
              },
              {
                "color0": "#2CCAFF",
                "color1": "#0090D4"
              }
            ],
            "light_color_scheme": [
              {
                "color0": "#B1B5FF",
                "color1": "#5F65FF"
              },
              {
                "color0": "#FFD3AA",
                "color1": "#E8A263"
              },
              {
                "color0": "#DD8EF9",
                "color1": "#C94EF0"
              },
              {
                "color0": "#36B2FA",
                "color1": "#0191D5"
              }
            ],
            "description": "",
            "post_process_function_name": "Development Cycle Chart Section"
          }
        ],
        "footer": [
          {
            "title": "Coding time",
            "description": "Coding Time measures the duration from the first commit to when the pull request is created.",
            "post_process_function_name": "Coding Time Footer Section",
            "spec_key": "codingTimeSpec"
          },
          {
            "title": "Code pickup time",
            "description": "Pickup Time reflects the time taken to start reviewing a PR, calculated from PR creation to the first review.",
            "post_process_function_name": "Coding Time Footer Section",
            "spec_key": "codingPickupTimeSpec"
          },
          {
            "title": "Code review time",
            "description": "Review Time measures the duration of the code review process, calculated from the start of the review to when the code is merged.",
            "post_process_function_name": "Coding Time Footer Section",
            "spec_key": "codingReviewTimeSpec"
          }
        ]
      }
    ]
  },
  "queries": {
    "avgDevelopmentHeader": {
      "alias": "dev_cycle_time_data",
      "query": {
        "_source": false,
        "size": 0,
        "query": {
          "bool": {
            "filter": [
              {
                "range": {
                  "timestamp": {
                    "gte": "{{.startDate}}",
                    "lte": "{{.endDate}}",
                    "format": "yyyy-MM-dd HH:mm:ss",
                    "time_zone": "{{.timeZone}}"
                  }
                }
              },
              {
                "term": {
                  "org_id": "{{.orgId}}"
                }
              }
            ]
          }
        },
        "aggs": {
          "developmentCycleTime": {
            "scripted_metric": {
              "init_script": "state.data_map=[:];",
              "map_script": "def map=state.data_map;def codingTime=0;def reviewTime=0;def deployTime=0;def pickupTime=0;if(doc.containsKey('coding_time')){if(doc['coding_time']!=null){codingTime=doc['coding_time'].value}}if(doc.containsKey('review_time')){if(doc['review_time']!=null){reviewTime=doc['review_time'].value}}if(doc.containsKey('pickup_time')){if(doc['pickup_time']!=null){pickupTime=doc['pickup_time'].value}}if(doc.containsKey('deploy_time')){if(doc['deploy_time']!=null){deployTime=doc['deploy_time'].value}}def key=doc.pull_request_id.value+'_'+doc.component_name.value+'_'+doc.repository_name.value+'_'+(doc.timestamp.getValue().toEpochSecond()*1000);def v=['pull_request_id':doc.pull_request_id.value,'coding_time':codingTime,'review_time':reviewTime,'pickup_time':pickupTime,'deploy_time':deployTime,'timestamp':(doc.timestamp.getValue().toEpochSecond()*1000),'repository_name':doc.repository_name.value];map.put(key,v);",
              "combine_script": "return state.data_map;",
              "reduce_script": "def tmpMap = [: ]; def out = [: ]; def countMap = new HashMap(); def metricsMap = new HashMap(); def developerSet = new HashSet(); DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern('dd MMM'); for (agg in states) { if (agg != null) { for (key in agg.keySet()) { def record = agg.get(key); def devkey = record.pull_request_id + record.repository_name; if (record['review_time'] <= 0 && record['pickup_time'] > 0 && record['pr_created_time'] != null) { long currentTimeInMilliSeconds = System.currentTimeMillis(); SimpleDateFormat sdf = new SimpleDateFormat('yyyy/MM/dd HH:mm:ss'); Date prCreatedTime = sdf.parse(record['pr_created_time']); long prCreatedTimeInMillis = prCreatedTime.getTime(); record['review_time'] = currentTimeInMilliSeconds - prCreatedTimeInMillis - (record['pickup_time'] * 1000); } if (tmpMap.containsKey(devkey)) { def mapRecord = tmpMap.get(devkey); if (mapRecord.timestamp < record.timestamp) { tmpMap.put(devkey, record); } } else { tmpMap.put(devkey, record); } } } } def timeArray = ['coding_time', 'pickup_time', 'review_time', 'deploy_time']; def timeArrayCount = ['coding_time': 0, 'pickup_time': 0, 'review_time': 0, 'deploy_time': 0]; for (key in tmpMap.keySet()) { def v = tmpMap.get(key); for (timeKey in timeArray) { if (countMap.containsKey(timeKey)) { def count = countMap.get(timeKey); count = count + v[timeKey]; countMap.put(timeKey, count); } else { countMap.put(timeKey, v[timeKey]); } if (v[timeKey] > 0) { timeArrayCount[timeKey] = timeArrayCount[timeKey] + 1; } } } def n = 0; for (timeKey in timeArray) { def x = countMap.get(timeKey); if (timeArrayCount[timeKey] > 0) { x = x / timeArrayCount[timeKey]; n = n + x; } } def duration = n * 1000; def day = n / (24 * 3600); n = n % (24 * 3600); def hour = n / 3600; n %= 3600; def minutes = n / 60; n %= 60; def seconds = n; def result = ''; if (day > 0) { result = result + day + 'd ' } if (hour > 0) { if (result.length() > 0) { result = result + hour + 'h ' } else { result = result + hour + 'h ' } } if (minutes > 0) { if (result.length() > 0) { result = result + minutes + 'm ' } else { result = result + minutes + 'm ' } } metricsMap.put('total', result); metricsMap.put('value', duration); return metricsMap;"
            }
          }
        }
      }
    },
    "developmentCycleChart": {
      "alias": "dev_cycle_time_data",
      "query": {
        "_source": false,
        "size": 0,
        "query": {
          "bool": {
            "filter": [
              {
                "range": {
                  "timestamp": {
                    "gte": "{{.startDate}}",
                    "lte": "{{.endDate}}",
                    "format": "yyyy-MM-dd HH:mm:ss",
                    "time_zone": "{{.timeZone}}"
                  }
                }
              },
              {
                "term": {
                  "org_id": "{{.orgId}}"
                }
              }
            ]
          }
        },
        "aggs": {
          "developmentCycleTime": {
            "scripted_metric": {
              "init_script": "state.data_map=[:];",
              "map_script": "def map=state.data_map;def codingTime=0;def reviewTime=0;def deployTime=0;def pickupTime=0;if(doc.containsKey('coding_time')){if(doc['coding_time']!=null){codingTime=doc['coding_time'].value}}if(doc.containsKey('review_time')){if(doc['review_time']!=null){reviewTime=doc['review_time'].value}}if(doc.containsKey('pickup_time')){if(doc['pickup_time']!=null){pickupTime=doc['pickup_time'].value}}if(doc.containsKey('deploy_time')){if(doc['deploy_time']!=null){deployTime=doc['deploy_time'].value}}def key=doc.pull_request_id.value+'_'+doc.component_name.value+'_'+doc.repository_name.value+'_'+(doc.timestamp.getValue().toEpochSecond()*1000);def v=['pull_request_id':doc.pull_request_id.value,'coding_time':codingTime,'review_time':reviewTime,'pickup_time':pickupTime,'deploy_time':deployTime,'timestamp':(doc.timestamp.getValue().toEpochSecond()*1000),'repository_name':doc.repository_name.value];map.put(key,v);",
              "combine_script": "return state.data_map;",
              "reduce_script": "def tmpMap = [: ]; def out = [: ]; def countMap = new HashMap(); def avgMap = new HashMap(); def metricsMap = new HashMap(); def developerSet = new HashSet(); DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern('dd MMM'); for (agg in states) { if (agg != null) { for (key in agg.keySet()) { def record = agg.get(key); def devkey = record.pull_request_id + record.repository_name; if (record['review_time'] <= 0 && record['pickup_time'] > 0 && record['pr_created_time'] != null) { long currentTimeInMilliSeconds = System.currentTimeMillis(); SimpleDateFormat sdf = new SimpleDateFormat('yyyy/MM/dd HH:mm:ss'); Date prCreatedTime = sdf.parse(record['pr_created_time']); long prCreatedTimeInMillis = prCreatedTime.getTime(); record['review_time'] = currentTimeInMilliSeconds - prCreatedTimeInMillis - (record['pickup_time'] * 1000); } if (tmpMap.containsKey(devkey)) { def mapRecord = tmpMap.get(devkey); if (mapRecord.timestamp < record.timestamp) { tmpMap.put(devkey, record); } } else { tmpMap.put(devkey, record); } } } } def timeArray = ['coding_time', 'pickup_time', 'review_time', 'deploy_time']; def timeArrayCount = ['coding_time': 0, 'pickup_time': 0, 'review_time': 0, 'deploy_time': 0]; for (key in tmpMap.keySet()) { def v = tmpMap.get(key); for (timeKey in timeArray) { if (countMap.containsKey(timeKey)) { def count = countMap.get(timeKey); count = count + v[timeKey]; countMap.put(timeKey, count); } else { countMap.put(timeKey, v[timeKey]); } if (v[timeKey] > 0) { timeArrayCount[timeKey] = timeArrayCount[timeKey] + 1; } } } def totalKey = 'total'; def total = 0; for (timeKey in timeArray) { def n = countMap.get(timeKey); if (timeArrayCount[timeKey] > 0) { n = n / timeArrayCount[timeKey]; } avgMap.put(timeKey, n); total = total + n; avgMap.put(totalKey, total); } for (timeKey in timeArray) { double sum = avgMap.get(totalKey); double count = avgMap.get(timeKey); double percent = Math.round((count * 100) / sum); metricsMap.put(timeKey, percent); } return metricsMap;"
            }
          }
        }
      }
    },
    "developmentTimeFooter": {
      "alias": "dev_cycle_time_data",
      "query": {
        "_source": false,
        "size": 0,
        "query": {
          "bool": {
            "filter": [
              {
                "range": {
                  "timestamp": {
                    "gte": "{{.startDate}}",
                    "lte": "{{.endDate}}",
                    "format": "yyyy-MM-dd HH:mm:ss",
                    "time_zone": "{{.timeZone}}"
                  }
                }
              },
              {
                "term": {
                  "org_id": "{{.orgId}}"
                }
              }
            ]
          }
        },
        "aggs": {
          "developmentCycleTime": {
            "scripted_metric": {
              "init_script": "state.data_map=[:];",
              "map_script": "def map=state.data_map;def codingTime=0;def reviewTime=0;def deployTime=0;def pickupTime=0;if(doc.containsKey('coding_time')){if(doc['coding_time']!=null){codingTime=doc['coding_time'].value}}if(doc.containsKey('review_time')){if(doc['review_time']!=null){reviewTime=doc['review_time'].value}}if(doc.containsKey('pickup_time')){if(doc['pickup_time']!=null){pickupTime=doc['pickup_time'].value}}if(doc.containsKey('deploy_time')){if(doc['deploy_time']!=null){deployTime=doc['deploy_time'].value}}def key=doc.pull_request_id.value+'_'+doc.component_name.value+'_'+doc.repository_name.value+'_'+(doc.timestamp.getValue().toEpochSecond()*1000);def v=['pull_request_id':doc.pull_request_id.value,'coding_time':codingTime,'review_time':reviewTime,'pickup_time':pickupTime,'deploy_time':deployTime,'timestamp':(doc.timestamp.getValue().toEpochSecond()*1000),'repository_name':doc.repository_name.value];map.put(key,v);",
              "combine_script": "return state.data_map;",
              "reduce_script": "def tmpMap = [: ]; def out = [: ]; def countMap = new HashMap(); def metricsMap = new HashMap(); def developerSet = new HashSet(); DateTimeFormatter dateFormat = DateTimeFormatter.ofPattern('dd MMM'); for (agg in states) { if (agg != null) { for (key in agg.keySet()) { def record = agg.get(key); def devkey = record.pull_request_id + record.repository_name; if (record['review_time'] <= 0 && record['pickup_time'] > 0 && record['pr_created_time'] != null) { long currentTimeInMilliSeconds = System.currentTimeMillis(); SimpleDateFormat sdf = new SimpleDateFormat('yyyy/MM/dd HH:mm:ss'); Date prCreatedTime = sdf.parse(record['pr_created_time']); long prCreatedTimeInMillis = prCreatedTime.getTime(); record['review_time'] = currentTimeInMilliSeconds - prCreatedTimeInMillis - (record['pickup_time'] * 1000); } if (tmpMap.containsKey(devkey)) { def mapRecord = tmpMap.get(devkey); if (mapRecord.timestamp < record.timestamp) { tmpMap.put(devkey, record); } } else { tmpMap.put(devkey, record); } } } } def timeArray = ['coding_time', 'pickup_time', 'review_time', 'deploy_time']; def timeArrayCount = ['coding_time': 0, 'pickup_time': 0, 'review_time': 0, 'deploy_time': 0]; for (key in tmpMap.keySet()) { def v = tmpMap.get(key); for (timeKey in timeArray) { if (countMap.containsKey(timeKey)) { def count = countMap.get(timeKey); count = count + v[timeKey]; countMap.put(timeKey, count); } else { countMap.put(timeKey, v[timeKey]); } if (v[timeKey] > 0) { timeArrayCount[timeKey] = timeArrayCount[timeKey] + 1; } } } for (timeKey in timeArray) { def n = countMap.get(timeKey); def key = timeKey + '_in_millis'; if (timeArrayCount[timeKey] > 0) { n = n / timeArrayCount[timeKey]; } def duration = n * 1000; def day = n / (24 * 3600); n = n % (24 * 3600); def hour = n / 3600; n %= 3600; def minutes = n / 60; n %= 60; def seconds = n; def result = ''; if (day > 0) { result = result + day + 'd ' } if (hour > 0) { if (result.length() > 0) { result = result + hour + 'h ' } else { result = result + hour + 'h ' } } if (minutes > 0) { if (result.length() > 0) { result = result + minutes + 'm ' } else { result = result + minutes + 'm ' } } if (day == 0 && hour == 0 && minutes == 0) { result = '0h 0m 0s' } metricsMap.put(timeKey, result); metricsMap.put(key, duration); } return metricsMap;"
            }
          }
        }
      }
    }
  }
}