{
    "widget": {
        "id": "e3",
        "title": "Automation runs",
        "description": "Track both successes and failures in your workflow run history for selected time frame.",
        "enable_components_compare": true,
        "components_compare_id": "workflow-runs-compare",
        "content": [
            {
                "header": [
                    {
                        "title": "Total runs",
                        "post_process_function_name": "automation runs",
                        "spec_key": "totalRunsHeaderSpec",
                        "drill_down": {
                            "report_id": "workflowRuns",
                            "report_title": "Workflow runs"
                        }
                    },
                    {
                        "type": "subHeader",
                        "post_process_function_name": "automation runs",
                        "spec_key": "totalRunsSubHeaderSpec"
                    }
                ],
                "section": [
                    {
                        "type": 5,
                        "show_legends": true,
                        "color_scheme": [
                            {
                                "color0": "#009C5B",
                                "color1": "#62CA9D"
                            },
                            {
                                "color0": "#D32227",
                                "color1": "#FB6E72"
                            }
                        ],
                        "light_color_scheme": [
                            {
                                "color0": "#0C9E61",
                                "color1": "#79CAA8"
                            },
                            {
                                "color0": "#E83D39",
                                "color1": "#F39492"
                            }
                        ],
                        "post_process_function_name": "automation runs",
                        "spec_key": "runsStatusChartSpec",
                        "enable_post_transformation_processing": true,
                        "drill_down": {
                            "report_id": "workflowRuns",
                            "report_title": "Workflow runs",
                            "report_type": "status"
                        }
                    }
                ]
            }
        ]
    },
    "queries": {
        "totalRunsSubHeader": {
            "alias": "automation_run_status",
            "query": {
                "size": 0,
                "query": {
                    "bool": {
                        "filter": [
                            {
                                "range": {
                                    "status_timestamp": {
                                        "gte": "{{.startDate}}",
                                        "lte": "{{.endDate}}",
                                        "format": "yyyy-MM-dd HH:mm:ss",
                                        "time_zone": "{{.timeZone}}"
                                    }
                                }
                            },
                            {
                                "term": {
                                    "org_id": "{{.orgId}}"
                                }
                            },
                            {
                                "term": {
                                    "job_id": ""
                                }
                            },
                            {
                                "term": {
                                    "step_id": ""
                                }
                            },
                            {
                                "bool": {
                                    "should": [
                                        {
                                            "term": {
                                                "status": "SUCCEEDED"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "FAILED"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "TIMED_OUT"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "ABORTED"
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                },
                "aggs": {
                    "automation_run": {
                        "scripted_metric": {
                            "init_script": "state.data_map=[:];",
                            "map_script": "def map = state.data_map;def key = doc.org_id+'_'+doc.automation_id.value + '_' + doc.run_id.value + '_' + doc.status.value;def v = ['run_id': doc.run_id.value, 'status': doc.status.value, 'status_timestamp': doc.status_timestamp.value, 'automation_id': doc.automation_id.value];map.put(key, v);",
                            "combine_script": "return state.data_map;",
                            "reduce_script": "def tmpMap = [:], out = [:], resultMap = new HashMap(), countMap = new HashMap(), totalCount = 0.0;for (response in states){if (response != null && response.size() > 0){for (key in response.keySet()){def record = response.get(key);def uniqueRunKey = record.automation_id + '_' + record.run_id;if (tmpMap.containsKey(uniqueRunKey)){def mapRecord = tmpMap.get(uniqueRunKey);if (mapRecord.status_timestamp.getMillis() > record.status_timestamp.getMillis()){if (mapRecord.status == 'SUCCEEDED'){mapRecord.status = 'Success';} else if (mapRecord.status == 'FAILED' || mapRecord.status == 'TIMED_OUT' || mapRecord.status == 'ABORTED'){mapRecord.status = 'Failure';}tmpMap.put(uniqueRunKey, mapRecord);}} else{if (record.status == 'SUCCEEDED'){record.status = 'Success';} else if (record.status == 'FAILED' || record.status == 'TIMED_OUT' || record.status == 'ABORTED'){record.status = 'Failure';}tmpMap.put(uniqueRunKey, record);}}}}for (key in tmpMap.keySet()){def mapRecord = tmpMap.get(key);if (countMap.containsKey(mapRecord.status)){def count = countMap.get(mapRecord.status);countMap.put(mapRecord.status, count + 1);totalCount++;} else{countMap.put(mapRecord.status, 1);totalCount++;}}def statusArray = ['Success', 'Failure'], dataArray = new ArrayList();for (key in statusArray){def count = 0, dataMap = new HashMap();if (countMap.containsKey(key)){count = countMap.get(key);}dataMap.put('title', key);dataMap.put('value', count);dataArray.add(dataMap)}resultMap.put('data', dataArray);return resultMap;"
                        }
                    }
                }
            }
        },
        "runsStatusChart": {
            "alias": "automation_run_status",
            "query": {
                "_source": false,
                "size": 0,
                "query": {
                    "bool": {
                        "filter": [
                            {
                                "range": {
                                    "status_timestamp": {
                                        "gte": "{{.startDate}}",
                                        "lte": "{{.endDate}}",
                                        "format": "yyyy-MM-dd HH:mm:ss",
                                        "time_zone": "{{.timeZone}}"
                                    }
                                }
                            },
                            {
                                "term": {
                                    "org_id": "{{.orgId}}"
                                }
                            },
                            {
                                "term": {
                                    "job_id": ""
                                }
                            },
                            {
                                "term": {
                                    "step_id": ""
                                }
                            },
                            {
                                "bool": {
                                    "should": [
                                        {
                                            "term": {
                                                "status": "SUCCEEDED"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "FAILED"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "TIMED_OUT"
                                            }
                                        },
                                        {
                                            "term": {
                                                "status": "ABORTED"
                                            }
                                        }
                                    ]
                                }
                            }
                        ]
                    }
                },
                "aggs": {
                    "runs_buckets": {
                        "date_histogram": {
                            "field": "status_timestamp",
                            "calendar_interval": "{{.aggrBy}}",
                            "min_doc_count": 0,
                            "format": "yyyy-MM-dd",
                            "time_zone": "{{.timeZone}}",
                            "extended_bounds": {
                                "min": "{{.dateHistogramMin}}",
                                "max": "{{.dateHistogramMax}}"
                            }
                        },
                        "aggs": {
                            "automation_run": {
                                "scripted_metric": {
                                    "init_script": "state.data_map=[:];",
                                    "map_script": "def map = state.data_map;def key = doc.org_id+'_'+doc.automation_id.value + '_' + doc.run_id.value + '_' + doc.status.value;def v = ['run_id': doc.run_id.value, 'status': doc.status.value, 'status_timestamp': doc.status_timestamp.value, 'automation_id': doc.automation_id.value];map.put(key, v);",
                                    "combine_script": "return state.data_map;",
                                    "reduce_script": "def tmpMap = [:], out = [:], resultMap = new HashMap(), countMap = new HashMap(), totalCount = 0.0;for (response in states){if (response != null && response.size() > 0){for (key in response.keySet()){def record = response.get(key);def uniqueRunKey = record.automation_id + '_' + record.run_id;if (tmpMap.containsKey(uniqueRunKey)){def mapRecord = tmpMap.get(uniqueRunKey);if (mapRecord.status_timestamp.getMillis() > record.status_timestamp.getMillis()){if (mapRecord.status == 'SUCCEEDED'){mapRecord.status = 'Success';} else if (mapRecord.status == 'FAILED' || mapRecord.status == 'TIMED_OUT' || mapRecord.status == 'ABORTED'){mapRecord.status = 'Failure';}tmpMap.put(uniqueRunKey, mapRecord);}} else{if (record.status == 'SUCCEEDED'){record.status = 'Success';} else if (record.status == 'FAILED' || record.status == 'TIMED_OUT' || record.status == 'ABORTED'){record.status = 'Failure';}tmpMap.put(uniqueRunKey, record);}}}}for (key in tmpMap.keySet()){def mapRecord = tmpMap.get(key);if (countMap.containsKey(mapRecord.status)){def count = countMap.get(mapRecord.status);countMap.put(mapRecord.status, count + 1);totalCount++;} else{countMap.put(mapRecord.status, 1);totalCount++;}}def statusArray = ['Success', 'Failure'];for (key in statusArray){def count = 0;if (countMap.containsKey(key)){count = countMap.get(key);}resultMap.put(key, count)}return resultMap;"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}